#!/usr/bin/env python

import json
import sys
import re 
from dirutil import *
from logger import * 
from map_table import * 
from gl import * 

#flags =1 means ignore case 
def do_search(flags, regex, content):
	logger.debug("regex search flag %d , regex is %s, content is %s "%(flags, regex,content))
	regex=regex.replace('\\', '\\\\')
	result=None
	match=0
	if flags == 1 :
		result=re.search(regex, content,re.I)
		if result == None:
			match=0
		else:
			match=1 
	else:
		result=re.search(regex, content)
		if result == None:
			match=0
		else:
			match=1
	logger.debug("regex search done, the result is %d  "%(match))
#one indicator return one list  result ,sub-indicators is a list 
	return match
def  cal_indicator(ioc_info,process_info,parent_code):
	logger.debug("go into cal_indicator")
	if "@mode"  not in  ioc_info.keys() or  ioc_info["@mode"]==0 or ioc_info["@mode"] == "0":
		logger.debug("there is no mode or mode =0 in cal_indicator")
#ret is the op bool value, code is the rating if the indicator is 1 
		ret=[]
		current_sub=[]
		if "@code" not in ioc_info.keys():
			code=parent_code
			ioc_info["@code"]=parent_code
		else:
			code=ioc_info["@code"]
# first get item value list under the current indicator,this list will merge the indicator value later 
		if "IndicatorItem"   in ioc_info.keys():
			for i in cal_indicatoritem(ioc_info,process_info):
				current_sub.append(i)
				ret.append(i[0])
#  two case here, a) one sub-indicator in current indicator b) many sub-indicator  
		if  "Indicator" in ioc_info.keys():
# one sub , directly do it 
			if type(ioc_info["Indicator"]) is dict:
				j=cal_indicator(ioc_info["Indicator"],process_info,code)
				ret.append(j[0])
				current_sub.append(j)
# put every sub-indicator  value into list 
			else:
				for i in ioc_info["Indicator"]:
					k=cal_indicator(i,process_info,code)
					current_sub.append(k)
					ret.append(k[0])
#find the max code,  return [0|1, code], 0|1 is oped on ret,  code is oped on current_sub
		logger.debug("the current indicator sub value and code is %s"%(current_sub))
		for  i   in  current_sub:
			if i[0]==1:
				if i[1] > code:
					code=i[1]

 
		op=ioc_info["@operator"]
		print "The OP is %s"%(op)
		beh=0
		if op == "AND":
			beh=0xfffff
			for  i in ret:
				beh=beh&i	
				print "the i is %s" %(i)
			return [beh,code]
		if op == "OR":
			beh=0
			for i  in ret:
				beh=beh|i
			return [beh,code] 
#		if op == "++":
#			i=0
#			for  j in  ret:
#				if j == 1:
#					i+=1
#			if i ==0: 
#				return  [i,0]
#			else:
#				return   [1,i]

#if ++,  return the number sum of each  match  times for  items.  item1 match log 10, item2 match log 20. then 
#return  [30,30]   
		if   op  == "++":
			logger.debug("it is an ++ operator, calculate the times of match")
			rest=cal_indicatoritem_times(ioc_info,process_info)
			return [rest, rest]
	logger.debug("there is specical mode  in cal_indicator")
#spec case,  use every log to iter the indicator and sub-indicator, if there is 1 for any log, the indicator is 1
#ret contains the result list of the indicator when log1 log2 ... 
#ret is or binary calculating, current_sub  contains [0|1, code]
#	ret=[]
#	current_sub=[]
#	code=None
#	and_list=[]
#	or_max=0

	for   i    in  process_info["information"]:
		ret=[]
		current_sub=[]
		code=None
		if "@code" not in ioc_info.keys():
			code=parent_code
			ioc_info["@code"]=parent_code
		else:
			code=ioc_info["@code"]
		and_list=[]
		or_max=0
		code_max=0
		logger.debug("using log  %s to calculating the now "%(i) )
		for j  in (call_items_log(ioc_info, i,process_info)):
			logger.debug("the current item result is %s"%j)
			ret.append(j[0])
			current_sub.append(j)
#  two case here, a) one sub-indicator in current indicator b) many sub-indicator  
		if  "Indicator" in ioc_info.keys():
# one sub , directly do it 
			if type(ioc_info["Indicator"]) is dict:
				foo=call_indicator_log(ioc_info["Indicator"],i,process_info, code)
				ret.append(foo[0])
				current_sub.append(foo)
# put every sub-indicator  value into list 
			else:
				for j in ioc_info["Indicator"]:
					foo=call_indicator_log(j,i,process_info, code)
					ret.append(foo[0])
					current_sub.append(foo)

		logger.debug("the current sub elements result is %s"%(current_sub))		
#calculate the OP value when log rolling 
		k=op_it(ioc_info,ret)
##calculate  the code of AND and OR 
#		if ioc_info["@operator"] == "AND":
#			for  i  in current_sub:
#				and_list.append(i[1])
#			logger.debug("the and_list now is %s"%(and_list))
#		if ioc_info["@operator"] == "OR":
#			for  i  in current_sub:
#				if i[1]> or_max:
#					or_max=i[1]
#
#
##once the OP is 1, return  right now 
#		if k == 1:
#			if ioc_info["@operator"] == "AND":
#				logger.debug("the specical case AND is 1 the list of AND is %s"%(and_list))
#				return [1,and_list]
#			 
#			
#			if ioc_info["@operator"] == "OR":
#				return [1,or_max]
#

# when mode =1 , just return the max code  if OP bin is 1 , so find the max code first, if the op is 1, return 1


		for  i   in  current_sub:
			if i[0]==1:
				if i[1] > code_max:
					code_max=i[1]
		
		if k==1:
			return [k,code_max]
#go through all logs, but no lucky, return  0 
#	if ioc_info["@operator"] == "AND":
#		logger.debug("the specical case AND is 0 after going through  logs. the list of AND is %s"%(and_list))
#		#return [0, and_list] 
#	
#	if ioc_info["@operator"] == "OR":
#		return [0, or_max]
#
	logger.debug("After checking all logs , no luck for mode=1 ,will return [0,0]")
	return [0,0]		
# get the indicator value , ret contains all items and directly sub-indicators
def op_it(node, ret):
	print (type(ret))
	print ret
	op=node["@operator"]
	beh=0
	if op == "AND":
		beh=0xfffff
		for  i in ret:
			print "the i is %s" %(i)
			beh=beh&i	
		return beh
	if op == "OR":
		beh=0
		for i  in ret:
			print "the i is %s" %(i)
			print type(i)
			beh=beh|i
		return beh 

#when log item roll in , the indicator value return [0|1] when log roll 
def call_indicator_log(node, log, process_info, parent_code):

#ret is binary result ,  current_sub contains binary and code value 
	ret=[] 
	code=None
	if "@code" not in node.keys():
		code=parent_code
		node["@code"]=parent_code
	else:
		code=node["@code"]
	and_list={}
	or_max=0
	current_sub=[]
	logger.debug("go into cal_indicator_log the indicator OP is %s"%(node["@operator"]))
	for i  in call_items_log(node,log,process_info):
		ret.append(i[0])
		current_sub.append(i)
	if "Indicator" in node.keys():
		if node["Indicator"].__class__.__name__ == "dict": 
			j=call_indicator_log(node["Indicator"] , log,code)
			ret.append(j[0])
			current_sub.append(j)
		else:
			for i  in  node["Indicator"]:
				j=call_indicator_log(i,log,code)
				ret.append(j[0])
				current_sub.append(j)



#if it is AND, return a list   OR retuen max


	k=op_it(node, ret)
	if node["@operator"] == "AND":
		for  i  in current_sub:
			and_list.append(i[1])
		logger.debug("the and_list in call_indicator_log is %s"%(and_list))
	if node["@operator"] == "OR":
		for  i  in current_sub:
			if i[1]> or_max:
				or_max=i[1]
		logger.debug("in call_indicator_log  the OR or_max is %d" %or_max)


	if k == 1:
		if node["@operator"] == "AND":
			logger.debug("It is AND, will return %d %s"%(k,and_list))
			return [1,and_list]
		 
			
		if node["@operator"] == "OR":
			logger.debug("It is OR,  will return %d %d"%(k,or_max))
			return [1,or_max]


	if k == 0:
		if node["@operator"] == "AND":
			logger.debug("It is AND, will return %d %s"%(k,and_list))
			return [k,and_list]
		 
			
		if node["@operator"] == "OR":
			logger.debug("It is OR, will return %d %d"%(k,or_max))
			return [k,or_max]


# return list of indicator items value when log roll in
def call_items_log(ioc_info, log,process_info):
	ret=[]
#if the ioc_info is dict, it means that there is only one item 
	if type(ioc_info["IndicatorItem"]) is dict:
		logger.debug("ther is only  one item during log rolling %s" %(ioc_info["IndicatorItem"]))
		ret.append(match_rule_log(ioc_info["IndicatorItem"], process_info,log,ioc_info["@code"]))
		logger.debug( "the indicator item during log rolling  list value is %s" %(ret)) 
		return   ret
# multi items 
	print "there are items ", ioc_info["IndicatorItem"],  type(ioc_info["IndicatorItem"]), len(ioc_info["IndicatorItem"])
	for i in ioc_info["IndicatorItem"]:
		ret.append(match_rule_log(i,process_info,log, ioc_info["@code"]))
	logger.debug( "the indicator item list value during log rolling  is %s" %(ret))
	return ret



type_map={
"FileItem": "file",
"ProcessItem":"process",
"RegistryItem": "registry"

}

action_map={
"CreateFile":"Create",	
"WriteFile":"write",
"ReadFile":"read",
"CreateProcess":"created",
"SetRegistry":"Modified",
"QueryRegistry":"GetValueKey"

}

#A\B\C
def break_search_text(search):
	type=type_map[search.split('\\')[0]]
	action=action_map[search.split('\\')[1]]
	property=search.split('\\')[2]
	logger.debug("break the %s into %s %s %s"%(search,type,action,property))
	return (type, action, property)

#return a list contains the value matched, used for cross_match value
def get_value_list(process_info,match_type, match_action,match_property=None):
	logger.debug("try to find out the result from process info ")
	ret=[]
	for   i    in  process_info["information"]:
		if  i["type"] ==match_type and i["action"] == match_action :
			if match_type == "file":
				ret.append(i["object1"])
			# object1 is PID, object2 is the path
			if match_type == "process":
				ret.append(i["object2"])
			if match_type  ==  "registry":
				ret.append(i["object1"])
	logger.debug("the value list for cross_match is %s"%(ret))
	return ret 


#get values matched A\B\C from logs,return a list  
def cal_container_value(item, process_info):
	(type, action, property)=break_search_text(item)
	return get_value_list(process_info,type,action,property)

# return [0|1] matches this rule when one log roll in 
def match_rule_log(item, process_info,log,parent_code):

	index=extract_list.index(process_info)
	logger.debug("match_rule_log will deal with the seq %d in extract_list "%(index))

	matched =0
	condition=item["@condition"]
	type=item["Context"]["@document"]
	act=item["Context"]["@search"]
#support array 
	content_array_flags=0
	content=None
	content_list=[]
# code store this item rating, code_item is for arary item . content_list is [[ a1, code] ,[a2,code]...]
	code=None
	container_list=[]
	code_item=None
#code_return is whether normal item rating ,or a rating from array 
	code_return=None
	if item["Content"]["@type"] == "string":
		content=item["Content"]["#text"]
		content=format_content(content)
		if "@code" not in item["Content"]:
			code=parent_code
		else:
			code=item["Content"]["@code"]
		print condition, type, act, content
#only one element, it is a dict instead of list 
	elif item["Content"]["@type"] == "array" and item["Content"]["Item"].__class__ is dict:
		content=item["Content"]["Item"]["#text"]
		logger.debug("it is only one array element ")
		if "@code" not in item["Content"]["Item"].keys():
			logger.debug("it has no code by default,using parent_code")
			code=parent_code
		else:
			code=item["Content"]["Item"]["@code"]
			logger.debug("it has default code %s"%(code))


	elif item["Content"]["@type"] == "array" and item["Content"]["Item"].__class__ is list :
		logger.debug("it is  multi array elements ")
		content_array_flags=1
		print item["Content"]
		for i  in item["Content"]["Item"]:
			if "@code" not in i.keys():
				logger.debug("elements %s: it has no code by default,using parent_code"%(i))
				code_item=parent_code
			else:
				code_item=i["@code"]
				logger.debug("elements %s: it has  code %s"%(i,code_item))
			if "#text"  in  i.keys():
				org=i["#text"]
				org=format_content(org)
				content_list.append([org,code_item])
				logger.debug("in multi array, the text and code list is: %s"%(content_list))

#support container, content_list now contains all matched log from container if has. 
#content_list is still [[match1,code] , [match2,code]... ] list 
	elif item["Content"]["@type"] == "container": 

		logger.debug("it is a container  type")
		content_array_flags = 1 
		container_list=cal_container_value(item["Content"]["#text"],process_info)

#deal code to form content_list
		if "@code" not in item["Content"].keys():
			code_item=parent_code
		else:
			code_item=item["Content"]["@code"]
		for g in  container_list:
			content_list.append([g,code_item])
	#print condition, type, act, content
	match_type=type_map[type]
	match_action=action_map[act.split('\\')[1]]
	match_property= act.split('\\')[2]

######
	logger.debug("in match_rule_log function, the match information is type %s, action %s, property %s" %(match_type,match_action,match_property))
# some process do nothing, so no information 
        if "information" not in process_info.keys():
            return [0,0]
	if  match_type not in process_info["hash_info"]:
		logger.debug("in match_rule_log function, there is no %s type in the hash log"%(match_type))
 		return [0,0]
	if match_action  not in  process_info["hash_info"][match_type]:
		logger.debug("in match_rule_log function, there is no %s action in the hash log "%(match_action))
		return [0,0]
	#for   log_index , i    in  enumerate(process_info["information"]):
	#for   log_index , i    in  enumerate(process_info["hash_info"][match_type][match_action]):
	list_fake=[]
	list_fake.append(log)
	for   i    in  list_fake:


		if  i["type"] ==match_type and i["action"] == match_action :
			logger.debug( "we found  a type/action line %s,will calculate the rule,the match_type is %s, match_action is %s , match_property is %s , content is %s " %(i,match_type,match_action,match_property,content))
			if content_array_flags  == 0:
			#file stuff
				if match_type == "file":
					if match_property.upper() == "FilePath".upper():
						if condition == "regex":
							ret=do_search(0, content, i["object1"])
							if ret == 1:
								matched=1
	
						if condition == "is" or condition == "eq":
							if content == i["object1"]:
								matched=1
						if  condition == "eq_i":
							if content.upper() == i["object1"].upper():
								matched=1
			
						if condition == "regex_i":
							ret=do_search(1,content, i["object1"])
							if ret == 1:
								matched=1
					if match_property.upper() == "Filetype".upper():
						if condition == "regex":
							ret=do_search(0, content, i["object1"].split('.')[-1])
							if ret == 1:
								matched=1
	
						if condition == "is" or condition == "eq":
							if content == i["object1"].split('.')[-1]:
								matched=1
						if  condition == "eq_i":
							if content.upper() == i["object1"].split('.')[-1].upper():
								matched=1
			
						if condition == "regex_i":
							ret=do_search(1,content, i["object1"].split('.')[-1])
							if ret == 1:
								matched=1
	
			
	
			#reg stuff
				if match_type == "registry":


					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched=1

			#process stuff
				if match_type == "process":
					logger.debug("bobo match the process rule,the process path is %s"%(i["object2"]))


					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched=1

					# it means the content value is other rule value instead of literal text
					if condition ==  "cross_match":
						#find matched items to get the value 
						(type, action, property)=break_search_text(content)				
						value_list=get_value_list(process_info,type, action)
						for   foo  in value_list:
							if i["object2"] == foo:
								matched =1 
					if condition ==  "cross_match_i":
						(type, action, property)=break_search_text(content)				
						#find matched items to get the value 
						value_list=get_value_list(process_info,type, action)
						for   foo in value_list:
							if i["object2"].upper() == foo.upper():
								matched =1 
			if content_array_flags  == 1:
			#file stuff
				if match_type == "file":
					# content_list is [text, code]
					if match_property.upper() == "FilePath".upper():
						if condition == "regex":
							for  j  in  content_list:
								ret=do_search(0, j[0], i["object1"])
								if ret == 1:
									matched=1
									code=j[1]
						if condition == "is" or condition == "eq":
							for  j  in  content_list:
								if j[0] == i["object1"]:
									matched=1
									code=j[1]
							
						if  condition == "eq_i":
							for  j  in  content_list:
								if j[0].upper() == i["object1"].upper():
									matched=1
									code=j[1]
						if condition == "regex_i":
							for  j  in  content_list:
								ret=do_search(1,j[0], i["object1"])
								if ret == 1:
									matched=1
									code=j[1]
			
					if match_property.upper() == "FileType".upper():
						if condition == "regex":
							for  j  in  content_list:
								ret=do_search(0, j[0], i["object1"].split('.')[-1])
								if ret == 1:
									matched=1
									code=j[1]
						if condition == "is" or condition == "eq":
							for  j  in  content_list:
								if j[0] == i["object1"].split('.')[-1]:
									matched=1
									code=j[1]
							
						if  condition == "eq_i":
							for  j  in  content_list:
								if j[0].upper() == i["object1"].split('.')[-1].upper():
									matched=1
									code=j[1]
						if condition == "regex_i":
							for  j  in  content_list:
								ret=do_search(1,j[0], i["object1"].split('.')[-1])
								if ret == 1:
									matched=1
									code=j[1]
	
			#reg stuff
				if match_type == "registry":

					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
			#process stuff
				if match_type == "process":
					logger.debug("bobo match the process rule,the process path is %s"%(i["object2"]))



					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]

					# it means the content value is other rule value instead of literal text
					if condition ==  "cross_match":
						#find matched items to get the value 
						(type, action, property)=break_search_text(content)				
						value_list=get_value_list(process_info,type, action)
						for   foo  in value_list:
							if i["object2"] == foo:
								matched =1 
					if condition ==  "cross_match_i":
						(type, action, property)=break_search_text(content)				
						#find matched items to get the value 
						value_list=get_value_list(process_info,type, action)
						for   foo in value_list:
							if i["object2"].upper() == foo.upper():
								matched =1 


	if matched == 0:
		logger.debug("in match_rule_log function, we uses log:%s to match item:%s  !!!NOTHING!! matched,code is %s "%(list_fake,item, code))
#############
	else:
			
		logger.debug("in match_rule_log function, we uses log:%s to match item:%s  It is  matched, code is %s "%(list_fake,item,code))
	return [matched, code]

#it calculate  the times of each matched item 
def cal_indicatoritem_times(ioc_info,process_info):
	logger.debug("the extract_list is  %s"%(extract_list))
	index=extract_list.index(process_info)
	logger.debug("will calculate how many times match dealing with the seq %d in extract_list "%(index))
	ret=0
#if the ioc_info is dict, it means that there is only one item 
	if type(ioc_info["IndicatorItem"]) is dict:
		logger.debug( "ther is only  one item", ioc_info["IndicatorItem"])
		ret=match_rule_times(ioc_info["IndicatorItem"], process_info,ioc_info["@code"])
		logger.debug("the indicator item match times value is %d" %(ret))
		return   ret
# multi items 
	print "there are items ", ioc_info["IndicatorItem"],  type(ioc_info["IndicatorItem"]), len(ioc_info["IndicatorItem"])
	for i in ioc_info["IndicatorItem"]:
		ret+=match_rule_times(i,process_info,ioc_info["@code"])
	logger.debug( "the indicator item match list match value sum is %d" %(ret))
	return ret
# it calculate  process_info logs match how much times from item 
def match_rule_times(item, process_info, parent_code):
	matched =0
	condition=item["@condition"]
	type=item["Context"]["@document"]
	act=item["Context"]["@search"]
#support array 
	content_array_flags=0
	content=None
	content_list=[]
# code store this item rating, code_item is for arary item . content_list is [[ a1, code] ,[a2,code]...]
	code=None
	container_list=[]
	code_item=None
#code_return is whether normal item rating ,or a rating from array 
	code_return=None
	if item["Content"]["@type"] == "string":
		content=item["Content"]["#text"]
		content=format_content(content)
		if "@code" not in item["Content"]:
			code=parent_code
		else:
			code=item["Content"]["@code"]
		print condition, type, act, content
#only one element, it is a dict instead of list 
	elif item["Content"]["@type"] == "array" and item["Content"]["Item"].__class__ is dict:
		content=item["Content"]["Item"]["#text"]
		content=format_content(content)
		if "@code" not in item["Content"]["Item"].keys():
			code=parent_code
		else:
			code=item["Content"]["Item"]["@code"]


	elif item["Content"]["@type"] == "array" and item["Content"]["Item"].__class__ is list :
		content_array_flags=1
		print item["Content"]
		for i  in item["Content"]["Item"]:
			if "@code" not in item["Content"]["Item"]:
				code_item=parent_code
			else:
				code_item=item["Content"]["Item"]["@code"]

			if "#text"  in  i.keys():
				org=i["#text"]
				org=format_content(org)
				content_list.append([org,code_item])

#support container, content_list now contains all matched log from container if has. 
#content_list is still [[match1,code] , [match2,code]... ] list 
	elif item["Content"]["@type"] == "container": 

		logger.debug("it is a container  type")
		content_array_flags = 1 
		container_list=cal_container_value(item["Content"]["#text"],process_info)
		logger.debug("the container value is %s" %(container))

#deal code to form content_list in container
		if "@code" not in item["Content"].keys():
			code_item=parent_code
		else:
			code_item=item["Content"]["@code"]
		for g in  container_list:
			content_list.append([g,code_item])
	#print condition, type, act, content
	match_type=type_map[type]
	match_action=action_map[act.split('\\')[1]]
	match_property= act.split('\\')[2]
	logger.debug("in match_rule_times function, the match information is type %s, action %s, property %s, content_array_flags %d" %(match_type,match_action,match_property,content_array_flags))
	if content_array_flags == 1:
		logger.debug("the content_array value is %s" %(content_list))

# some process do nothing, so no information 
	if "information" not in process_info.keys():
        	return  0
#optimize it only search hash_info 
	if  match_type not in process_info["hash_info"]:
 		return 0
	if match_action  not in  process_info["hash_info"][match_type]:
		return 0
	#for   log_index , i    in  enumerate(process_info["information"]):
	for   log_index , i    in  enumerate(process_info["hash_info"][match_type][match_action]):
	#for   log_index , i    in  enumerate(process_info["information"]):
		#log_index=process_info["information"].index(i)
		seq_index=extract_list.index(process_info)
		logger.debug("process the %dth log  total current log number %d  for seq %d ,log content:%s "%(log_index,len(process_info["information"]), seq_index,i))
		if  i["type"] ==match_type and i["action"] == match_action :
			logger.debug( "we found  a type/action line %s,will calculate the rule,the match_type is %s, match_action is %s , match_property is %s , content is %s for ++ operator " %(i,match_type,match_action,match_property,content))

			if content_array_flags  == 0:
			#file stuff
				if match_type == "file":
					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched+=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched+=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched+=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched+=1
	
			
	
			#reg stuff
				if match_type == "registry":


					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched+=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched+=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched+=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched+=1

			#process stuff
				if match_type == "process":
					logger.debug("bobo match the process rule,the process path is %s"%(i["object2"]))


					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched+=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched+=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched+=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched+=1

					# it means the content value is other rule value instead of literal text
					if condition ==  "cross_match":
						#find matched items to get the value 
						(type, action, property)=break_search_text(content)				
						value_list=get_value_list(process_info,type, action)
						for   foo  in value_list:
							if i["object2"] == foo:
								matched+=1 
					if condition ==  "cross_match_i":
						(type, action, property)=break_search_text(content)				
						#find matched items to get the value 
						value_list=get_value_list(process_info,type, action)
						for   foo in value_list:
							if i["object2"].upper() == foo.upper():
								matched+=1 
			if content_array_flags  == 1:
			#file stuff
				if match_type == "file":
					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched+=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched+=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched+=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched+=1
								code=j[1]
			
	
			#reg stuff
				if match_type == "registry":

					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched+=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched+=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched+=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched+=1
								code=j[1]
			#process stuff
				if match_type == "process":
					logger.debug("bobo match the process rule,the process path is %s"%(i["object2"]))



					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched+=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched+=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched+=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched+=1
								code=j[1]

					# it means the content value is other rule value instead of literal text
					if condition ==  "cross_match":
						#find matched items to get the value 
						(type, action, property)=break_search_text(content)				
						value_list=get_value_list(process_info,type, action)
						for   foo  in value_list:
							if i["object2"] == foo:
								matched+=1 
					if condition ==  "cross_match_i":
						(type, action, property)=break_search_text(content)				
						#find matched items to get the value 
						value_list=get_value_list(process_info,type, action)
						for   foo in value_list:
							if i["object2"].upper() == foo.upper():
								matched+=1 


			logger.debug("in match_rule_times:  the current log  type/action is matched, and the times of match %d "%(matched))
		else:
			logger.debug("in match_rule_times: the current type is %s, item need type is %s : the current action is %s, the item  action is %s , continue to next log " %(i["type"],i["action"], match_type,match_action))



	logger.debug("the match number for this item is %d"%(matched))
	return matched


#replace the window marco 
def  format_content(content):
	logger.debug("the orgin content is %s"%content)
	for i  in  window_macro_map.keys():
		content=content.replace(i, window_macro_map[i])
	logger.debug("after the replace is %s"%(content))
	return content

#item is a dict of rule, return [ 0|1 , code ] matches this rule
#if code is defined, use it or  inherit from parent 
def match_rule(item, process_info, parent_code):
	logger.debug("the extract_list is  %s"%(extract_list))
	index=extract_list.index(process_info)
	logger.debug("match_rule will deal with the seq %d in extract_list "%(index))
	matched =0
	condition=item["@condition"]
	type=item["Context"]["@document"]
	act=item["Context"]["@search"]
#support array 
	content_array_flags=0
	content=None
	content_list=[]
# code store this item rating, code_item is for arary item . content_list is [[ a1, code] ,[a2,code]...]
	code=None
	container_list=[]
	code_item=None
#code_return is whether normal item rating ,or a rating from array 
	code_return=None
	if item["Content"]["@type"] == "string":
		content=item["Content"]["#text"]
		content=format_content(content)
		if "@code" not in item["Content"]:
			code=parent_code
		else:
			code=item["Content"]["@code"]
		print condition, type, act, content
#only one element, it is a dict instead of list 
	elif item["Content"]["@type"] == "array" and item["Content"]["Item"].__class__ is dict:
		content=item["Content"]["Item"]["#text"]
		if "@code" not in item["Content"]["Item"].keys():
			code=parent_code
		else:
			code=item["Content"]["Item"]["@code"]


	elif item["Content"]["@type"] == "array" and item["Content"]["Item"].__class__ is list :
		content_array_flags=1
		print item["Content"]
		for i  in item["Content"]["Item"]:
			if "@code" not in item["Content"]["Item"]:
				code_item=parent_code
			else:
				code_item=item["Content"]["Item"]["@code"]

			if "#text"  in  i.keys():
				org=i["#text"]
				org=format_content(org)
				content_list.append([org,code_item])

#support container, content_list now contains all matched log from container if has. 
#content_list is still [[match1,code] , [match2,code]... ] list 
	elif item["Content"]["@type"] == "container": 

		logger.debug("it is a container  type")
		content_array_flags = 1 
		container_list=cal_container_value(item["Content"]["#text"],process_info)
		logger.debug("the container value is %s" %(container))

#deal code to form content_list in container
		if "@code" not in item["Content"].keys():
			code_item=parent_code
		else:
			code_item=item["Content"]["@code"]
		for g in  container_list:
			content_list.append([g,code_item])
	#print condition, type, act, content
	match_type=type_map[type]
	match_action=action_map[act.split('\\')[1]]
	match_property= act.split('\\')[2]
	logger.debug("in match_rule function, the match information is type %s, action %s, property %s, content_array_flags %d" %(match_type,match_action,match_property,content_array_flags))
	if content_array_flags == 1:
		logger.debug("the content_array value is %s" %(content_list))

# some process do nothing, so no information 
	if "information" not in process_info.keys():
        	return [0,0]
#optimize it only search hash_info 
	if  match_type not in process_info["hash_info"]:
 		return [0,0]
	if match_action  not in  process_info["hash_info"][match_type]:
		return [0,0]
	#for   log_index , i    in  enumerate(process_info["information"]):
	for   log_index , i    in  enumerate(process_info["hash_info"][match_type][match_action]):
		#log_index=process_info["information"].index(i)
		seq_index=extract_list.index(process_info)
		logger.debug("process the %dth log  total current log number %d  for seq %d ,log content:%s "%(log_index,len(process_info["information"]), seq_index,i))
		if  i["type"] ==match_type and i["action"] == match_action :
			logger.debug( "we found  a type/action line %s,will calculate the rule,the match_type is %s, match_action is %s , match_property is %s , content is %s " %(i,match_type,match_action,match_property,content))


			if content_array_flags  == 0:
			#file stuff
				if match_type == "file":
					if match_property.upper() == "FilePath".upper():
						if condition == "regex":
							ret=do_search(0, content, i["object1"])
							if ret == 1:
								matched=1
	
						if condition == "is" or condition == "eq":
							if content == i["object1"]:
								matched=1
						if  condition == "eq_i":
							if content.upper() == i["object1"].upper():
								matched=1
			
						if condition == "regex_i":
							ret=do_search(1,content, i["object1"])
							if ret == 1:
								matched=1
	
			
					if match_property.upper() == "FileType".upper():
						if condition == "regex":
							ret=do_search(0, content, i["object1"].split('.')[-1])
							if ret == 1:
								matched=1
	
						if condition == "is" or condition == "eq":
							if content == i["object1"].split('.')[-1]:
								matched=1
						if  condition == "eq_i":
							if content.upper() == i["object1"].split('.')[-1].upper():
								matched=1
			
						if condition == "regex_i":
							ret=do_search(1,content, i["object1"].split('.')[-1])
							if ret == 1:
								matched=1
	
			#reg stuff
				if match_type == "registry":


					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched=1

			#process stuff
				if match_type == "process":
					logger.debug("bobo match the process rule,the process path is %s"%(i["object2"]))


					if condition == "regex":
						ret=do_search(0, content, i["object1"])
						if ret == 1:
							matched=1
	
					if condition == "is" or condition == "eq":
						if content == i["object1"]:
							matched=1
					if  condition == "eq_i":
						if content.upper() == i["object1"].upper():
							matched=1
			
					if condition == "regex_i":
						ret=do_search(1,content, i["object1"])
						if ret == 1:
							matched=1

					# it means the content value is other rule value instead of literal text
					if condition ==  "cross_match":
						#find matched items to get the value 
						(type, action, property)=break_search_text(content)				
						value_list=get_value_list(process_info,type, action)
						for   foo  in value_list:
							if i["object2"] == foo:
								matched =1 
					if condition ==  "cross_match_i":
						(type, action, property)=break_search_text(content)				
						#find matched items to get the value 
						value_list=get_value_list(process_info,type, action)
						for   foo in value_list:
							if i["object2"].upper() == foo.upper():
								matched =1 
			if content_array_flags  == 1:
			#file stuff
				if match_type == "file":
					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
			
	
			#reg stuff
				if match_type == "registry":

					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
			#process stuff
				if match_type == "process":
					logger.debug("bobo match the process rule,the process path is %s"%(i["object2"]))



					# content_list is [text, code]
					if condition == "regex":
						for  j  in  content_list:
							ret=do_search(0, j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]
					if condition == "is" or condition == "eq":
						for  j  in  content_list:
							if j[0] == i["object1"]:
								matched=1
								code=j[1]
						
					if  condition == "eq_i":
						for  j  in  content_list:
							if j[0].upper() == i["object1"].upper():
								matched=1
								code=j[1]
					if condition == "regex_i":
						for  j  in  content_list:
							ret=do_search(1,j[0], i["object1"])
							if ret == 1:
								matched=1
								code=j[1]

					# it means the content value is other rule value instead of literal text
					if condition ==  "cross_match":
						#find matched items to get the value 
						(type, action, property)=break_search_text(content)				
						value_list=get_value_list(process_info,type, action)
						for   foo  in value_list:
							if i["object2"] == foo:
								matched =1 
					if condition ==  "cross_match_i":
						(type, action, property)=break_search_text(content)				
						#find matched items to get the value 
						value_list=get_value_list(process_info,type, action)
						for   foo in value_list:
							if i["object2"].upper() == foo.upper():
								matched =1 
#######################
			logger.debug("in match_rule:  the current log  type/action is matched, and the text compared result %d "%(matched))
		else:
			logger.debug("in match_rule: the current type is %s, item need type is %s : the current action is %s, the item  action is %s , continue to next log " %(i["type"],i["action"], match_type,match_action))

	if matched == 1:
		logger.debug(" in match_rule :After current logs is checked,  Matchs a rule !!!!!")
	else:
		logger.debug("in match_rule: no luck to match the rule for all current logs ")
	return [matched, code]
#return a list [ 1, 0, 1 , 1... ] each is a return value of ruleN

def cal_indicatoritem(ioc_info,process_info):
	ret=[]
#if the ioc_info is dict, it means that there is only one item 
	if type(ioc_info["IndicatorItem"]) is dict:
		print "ther is only  one item", ioc_info["IndicatorItem"] 
		ret.append(match_rule(ioc_info["IndicatorItem"], process_info,ioc_info["@code"]))
		print "the indicator item list value is %s" %(ret)
		return   ret
# multi items 
	print "there are items ", ioc_info["IndicatorItem"],  type(ioc_info["IndicatorItem"]), len(ioc_info["IndicatorItem"])
	for i in ioc_info["IndicatorItem"]:
		ret.append(match_rule(i,process_info,ioc_info["@code"]))
	print "the indicator item list value is %s" %(ret)
	return ret


def get_process_behavior_list(process_info,behavior_path):
	ret =[]
	name=[]
	code=[]
	logger.debug("reading behavior_path %s to calculate process %s" %(behavior_path,process_info))
	for i  in  get_files_for_dir(behavior_path):
		f=open(i, 'r')
		logger.debug("reading the behavior file: %s"%i)
		j=json.load(f)
		name.append(j["Behaviour"]["@description"])
		logger.debug("dealing with behavior %s " %(j["Behaviour"]["@description"]))
		foo=cal_indicator(j["Behaviour"]["Indicator"], process_info,1)
		if j["Behaviour"]["Indicator"]["@operator"] == "++":
			#ret.append(foo)
			print  "the behavior is %d " %foo[0]
		else:
			print  "the behavior is %d " %foo[0]
	#code value maybe list or value 
			if type(foo[1]) is list:
				print  "the behavior code is %s" %foo[1]
			else:
				print  "the behavior code is %d" %int(foo[1])
		logger.debug("dealing with behavior %s is done"%( j["Behaviour"]["@description"]))
		logger.debug("dealing with behavior %s result: binary value:%s  code value:%s"%( j["Behaviour"]["@description"], foo[0], foo[1]))
		code.append(foo[1])
		ret.append(foo[0])
	print  "behavior name list  %s" %(name)
	print  "behavior result %s"%(ret)
	print  "behavior code  %s"%(code)
	return [name,ret,code]
